import{$ as V,a0 as C,a1 as x,a2 as M,r as v}from"./index-e80d72a1.js";function O(e){e.values.forEach(t=>t.stop())}function T(){const e=new Set,t={subscribe(r){return e.add(r),()=>void e.delete(r)},start(r,s){const u=[];return e.forEach(o=>{u.push(V(o,r,{transitionOverride:s}))}),Promise.all(u)},set(r){return e.forEach(s=>{C(s,r)})},stop(){e.forEach(r=>{O(r)})},mount(){return()=>{t.stop()}}};return t}function $(){const e=x(T);return M(e.mount,[]),e}const _=$;var E=new Map,b=new WeakMap,S=0,B=void 0;function j(e){return e?(b.has(e)||(S+=1,b.set(e,S.toString())),b.get(e)):"0"}function z(e){return Object.keys(e).sort().filter(t=>e[t]!==void 0).map(t=>`${t}_${t==="root"?j(e.root):e[t]}`).toString()}function L(e){let t=z(e),r=E.get(t);if(!r){const s=new Map;let u;const o=new IntersectionObserver(i=>{i.forEach(n=>{var h;const c=n.isIntersecting&&u.some(a=>n.intersectionRatio>=a);e.trackVisibility&&typeof n.isVisible>"u"&&(n.isVisible=c),(h=s.get(n.target))==null||h.forEach(a=>{a(c,n)})})},e);u=o.thresholds||(Array.isArray(e.threshold)?e.threshold:[e.threshold||0]),r={id:t,observer:o,elements:s},E.set(t,r)}return r}function P(e,t,r={},s=B){if(typeof window.IntersectionObserver>"u"&&s!==void 0){const c=e.getBoundingClientRect();return t(s,{isIntersecting:s,target:e,intersectionRatio:typeof r.threshold=="number"?r.threshold:0,time:0,boundingClientRect:c,intersectionRect:c,rootBounds:c}),()=>{}}const{id:u,observer:o,elements:i}=L(r);let n=i.get(e)||[];return i.has(e)||i.set(e,n),n.push(t),o.observe(e),function(){n.splice(n.indexOf(t),1),n.length===0&&(i.delete(e),o.unobserve(e)),i.size===0&&(o.disconnect(),E.delete(u))}}function q({threshold:e,delay:t,trackVisibility:r,rootMargin:s,root:u,triggerOnce:o,skip:i,initialInView:n,fallbackInView:c,onChange:h}={}){var A;const[a,y]=v.useState(null),l=v.useRef(),[g,R]=v.useState({inView:!!n,entry:void 0});l.current=h,v.useEffect(()=>{if(i||!a)return;let d;return d=P(a,(I,p)=>{R({inView:I,entry:p}),l.current&&l.current(I,p),p.isIntersecting&&o&&d&&(d(),d=void 0)},{root:u,rootMargin:s,threshold:e,trackVisibility:r,delay:t},c),()=>{d&&d()}},[Array.isArray(e)?e.toString():e,a,u,s,o,i,r,c,t]);const m=(A=g.entry)==null?void 0:A.target,w=v.useRef();!a&&m&&!o&&!i&&w.current!==m&&(w.current=m,R({inView:!!n,entry:void 0}));const f=[y,g.inView,g.entry];return f.ref=f[0],f.inView=f[1],f.entry=f[2],f}export{_ as a,q as u};
